现在我有一个数据集：

数据是宽带IQ采样一维数据，文件格式为.bin文件，使用python可以这样读取：
waveform_bin = np.fromfile(bin_path, dtype=np.float16)
waveform = waveform_bin[::2] + 1j * waveform_bin[1::2]

标签是.json文件，例如：
{
  "signals": [
    {
      "signal_id": 0,
      "start_frequency": 2447.0,
      "end_frequency": 2467.0,
      "start_time": 34.0,
      "end_time": 51.0,
      "class": 2
    },
    {
      "signal_id": 1,
      "start_frequency": 2459.97385,
      "end_frequency": 2460.02615,
      "start_time": 0.0,
      "end_time": 60.999869999999994,
      "class": 9
    },
    {
      "signal_id": 2,
      "start_frequency": 2446.875,
      "end_frequency": 2447.125,
      "start_time": 70.0,
      "end_time": 80.0,
      "class": 9
    },
    {
      "signal_id": 3,
      "start_frequency": 2467.5,
      "end_frequency": 2468.5,
      "start_time": 71.0,
      "end_time": 100.0,
      "class": 6
    },
    {
      "signal_id": 4,
      "start_frequency": 2466.0,
      "end_frequency": 2468.0,
      "start_time": 36.0,
      "end_time": 100.0,
      "class": 8
    },
    {
      "signal_id": 5,
      "start_frequency": 2449.5,
      "end_frequency": 2450.5,
      "start_time": 4.0,
      "end_time": 49.0,
      "class": 6
    }
  ],
  "observation_range": [
    2444.0,
    2474.0
  ]
}
标注出了信号的个数以及每个信号的起止频率（MHz单位）和起止时间（ms单位）和制式种类（共14种，即0到13），以及这个标签对应的数据所观测的频率范围（MHz单位）

已知每个数据的采样频率就是这个数据所观测的频率范围（IQ采样下的奈奎斯特采样定律），且数据的采样率可能为 5Ms/s、20Ms/s、30Ms/s、40Ms/s、50Ms/s、80Ms/s，那么每个数据的采样时长就可以通过.bin文件读取后的采样点数和采样频率计算得出。

每个数据和标签的名称为对应的 i.bin 和 i.json（这里i指整数，如 1.bin对应1.json）

现在，由于数据之间的采样频率和采样时长并不统一，造成以下问题：
假设有一个相同的信号（相同制式，相同时频范围），在两个不同采样频率的数据中出现。假如我为了输入神经网络的STFT二维时频图尺寸完全统一，则要采用不同的频率和时间分辨率进行STFT，则信号在不同样本间的样子就会发生改变。但是假如我使用统一的频率分辨率和时间分辨率进行STFT，那么数据处理后得到的STFT图的尺寸就不统一（比如说有(200,400)的，也有(1600,1500)的），如果直接输入yolo的话会进行resize的压缩，还是导致不同数据中相同信号变得不同。

因此，请你帮我写一段代码，完成以下任务：
1. 以固定的 50kHz+0.01ms 的频率+时间分辨率对一维IQ采样数据进行STFT，则 40Ms/s+80ms 的样本处理后结果即为 (800,8000) 尺寸；
2. 以 (800, 800) 为标准尺寸，如果样本以上述固定分辨率进行STFT后尺寸小于标准尺寸，则补零到标准尺寸；如果样本以上述固定分辨率进行STFT后尺寸大于标准尺寸，则对大于标准尺寸的轴进行50%的重叠切片（比如：某个样本以上述固定分辨率进行STFT后尺寸为(1600,1500)，那么切片后得到 (0-800, 0-800)、(400-1200, 0-800)、(800-1600, 0-800)、(0-800, 400-1200)、(400-1200, 400-1200)、(800-1600, 400-1200)、(0-800, 700-1500)、(400-1200, 700-1500)、(800-1600, 700-1500) 共9个切片）
3. 得到STFT图后，对每个点（复数）取模，并输出为png，得到单通道灰度图。
4. 对于标签，处理比较复杂：假如此标签对应的数据需补零到标准尺寸，那么标签内信号按(800,800)对应的40Ms/s+80ms进行归一化，并转化为 class, cx_norm, cy_norm, w_norm, h_norm 的YOLO训练标签，写入与数据STFT图对应名字的.txt文件中；假如此标签对应的数据需要切片，首先计算每个切片中存在的信号的标签，然后再归一化，然后再转化为 class, cx_norm, cy_norm, w_norm, h_norm 的YOLO训练标签，写入与数据STFT图对应名字的.txt文件中；
5. 对于需要补零和正好标准尺寸的，数据的STFT图的输出名字为 n.png，其中n指的是第几个数据，标签输出文件名为对应的 n.txt；对于需要切片的，数据的STFT图的输出名字为 n_i.png，其中n指的是第几个数据，i指的是第几个切片，n和i均为整数，标签输出文件名为对应的 n_i.txt；
6. 首先按照8:2的比例划分训练集和验证集以后再进行操作，最后的保存路径为：
dataset_ver2
  \images
    \train
      \ xx.png
    \val
      \ xx.txt
  \labels
    \train
      \ xx.png
    \val
      \ xx.txt

原始数据集的绝对路径为：D:\workspace_ai_radio\workspace_final_2\dataset\train，即：
train
  \0.bin
  \0.json
  \1.bin
  \1.json
  \...以此类推

请给出实现上述功能的完整python代码。